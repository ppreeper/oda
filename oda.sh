#!/usr/bin/env bash
# This script was generated by bashly 1.0.5 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
	printf "bash version 4 or higher is required\n" >&2
	exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
	echo "$version"
}

# :command.usage
oda.sh_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh - Odoo Administration Tool\n"
		echo

	else
		printf "oda.sh - Odoo Administration Tool\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh COMMAND\n"
	printf "  oda.sh [COMMAND] --help | -h\n"
	printf "  oda.sh --version | -v\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   additional config options\n" "config  "
	printf "  %s   Start the instance\n" "start   "
	printf "  %s   Stop the instance\n" "stop    "
	printf "  %s   Restart the instance\n" "restart "
	printf "  %s   Follow the logs\n" "logs    "
	printf "  %s   Generates an Odoo module skeleton in addons\n" "scaffold"
	printf "  %s   initialize the database\n" "init    "
	printf "  %s   Install module(s)\n" "install "
	printf "  %s   Upgrade module(s)\n" "upgrade "
	printf "  %s   export import module manifest\n" "manifest"
	printf "  %s   Access the raw database\n" "psql    "
	printf "  %s   Query the database\n" "query   "
	printf "  %s   Backup database filestore and addons\n" "backup  "
	printf "  %s   Restore database and filestore or addons\n" "restore "
	printf "  %s   Admin user management\n" "admin   "
	printf "  %s   Project level commands [CAUTION]\n" "project "
	printf "  %s   Odoo community and enterprise repository management\n" "repo    "
	printf "  %s   node management commands\n" "node    "
	printf "  %s   odoofs server management commands\n" "fs      "
	printf "  %s   manage remote servers via ssh commands\n" "remote  "
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo
		printf "  %s\n" "--version, -v"
		printf "    Show version number\n"
		echo

		# :command.usage_environment_variables
		printf "%s\n" "Environment Variables:"

		# :environment_variable.usage
		printf "  %s\n" "POD"
		printf "    Odoo instance\n"
		printf "    Default: ${PWD##*/}\n"
		echo

	fi
}

# :command.usage
oda.sh_config_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh config - additional config options\n"
		echo

	else
		printf "oda.sh config - additional config options\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh config COMMAND\n"
	printf "  oda.sh config [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Setup vscode settings and launch json files\n" "vscode "
	printf "  %s   Setup pyright settings\n" "pyright"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_config_vscode_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh config vscode - Setup vscode settings and launch json files\n"
		echo

	else
		printf "oda.sh config vscode - Setup vscode settings and launch json files\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh config vscode\n"
	printf "  oda.sh config vscode --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_config_pyright_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh config pyright - Setup pyright settings\n"
		echo

	else
		printf "oda.sh config pyright - Setup pyright settings\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh config pyright\n"
	printf "  oda.sh config pyright --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_start_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh start - Start the instance\n"
		echo

	else
		printf "oda.sh start - Start the instance\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh start\n"
	printf "  oda.sh start --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda start\n"
		echo

	fi
}

# :command.usage
oda.sh_stop_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh stop - Stop the instance\n"
		echo

	else
		printf "oda.sh stop - Stop the instance\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh stop\n"
	printf "  oda.sh stop --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda stop\n"
		echo

	fi
}

# :command.usage
oda.sh_restart_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh restart - Restart the instance\n"
		echo

	else
		printf "oda.sh restart - Restart the instance\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh restart\n"
	printf "  oda.sh restart --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda stop\n"
		echo

	fi
}

# :command.usage
oda.sh_logs_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh logs - Follow the logs\n"
		echo

	else
		printf "oda.sh logs - Follow the logs\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh logs\n"
	printf "  oda.sh logs --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda logs\n"
		echo

	fi
}

# :command.usage
oda.sh_scaffold_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh scaffold - Generates an Odoo module skeleton in addons\n"
		echo

	else
		printf "oda.sh scaffold - Generates an Odoo module skeleton in addons\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh scaffold MODULE\n"
	printf "  oda.sh scaffold --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "MODULE"
		printf "    Name of the module to create\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda scaffold module_ext\n"
		echo

	fi
}

# :command.usage
oda.sh_init_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh init - initialize the database\n"
		echo

	else
		printf "oda.sh init - initialize the database\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh init [MODULES] [OPTIONS]\n"
	printf "  oda.sh init --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--name, -d NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "MODULES"
		printf "    comma seperated list of modules\n"
		printf "    Default: base,l10n_ca\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda init\n"
		echo

	fi
}

# :command.usage
oda.sh_install_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh install - Install module(s)\n"
		echo

	else
		printf "oda.sh install - Install module(s)\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh install MODULES [OPTIONS]\n"
	printf "  oda.sh install --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--name, -d NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "MODULES"
		printf "    comma seperated list of modules\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda install base,web\n"
		echo

	fi
}

# :command.usage
oda.sh_upgrade_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh upgrade - Upgrade module(s)\n"
		echo

	else
		printf "oda.sh upgrade - Upgrade module(s)\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh upgrade MODULES [OPTIONS]\n"
	printf "  oda.sh upgrade --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--name, -d NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "MODULES"
		printf "    comma seperated list of modules\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda upgrade base,web\n"
		echo

	fi
}

# :command.usage
oda.sh_manifest_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh manifest - export import module manifest\n"
		echo

	else
		printf "oda.sh manifest - export import module manifest\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh manifest COMMAND\n"
	printf "  oda.sh manifest [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   export manifest.json\n" "export"
	printf "  %s   import manifest.json\n" "import"
	printf "  %s   download manifest from backup\n" "remote"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_manifest_export_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh manifest export - export manifest.json\n"
		echo

	else
		printf "oda.sh manifest export - export manifest.json\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh manifest export\n"
	printf "  oda.sh manifest export --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_manifest_import_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh manifest import - import manifest.json\n"
		echo

	else
		printf "oda.sh manifest import - import manifest.json\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh manifest import [FILE]\n"
	printf "  oda.sh manifest import --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "FILE"
		printf "    manifest file to read\n"
		printf "    Default: manifest.json\n"
		echo

	fi
}

# :command.usage
oda.sh_manifest_remote_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh manifest remote - download manifest from backup\n"
		echo

	else
		printf "oda.sh manifest remote - download manifest from backup\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh manifest remote FILE\n"
	printf "  oda.sh manifest remote --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "FILE"
		printf "    backup file to read\n"
		echo

	fi
}

# :command.usage
oda.sh_psql_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh psql - Access the raw database\n"
		echo

	else
		printf "oda.sh psql - Access the raw database\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh psql [OPTIONS]\n"
	printf "  oda.sh psql --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--host HOST"
		printf "    Database Host\n"
		printf "    Default: $(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--port PORT"
		printf "    Database Port\n"
		printf "    Default: $(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--user USERNAME"
		printf "    Username\n"
		printf "    Default: $(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--pass PASS"
		printf "    Password\n"
		printf "    Default: $(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--name NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda psql\n"
		echo

	fi
}

# :command.usage
oda.sh_query_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh query - Query the database\n"
		echo

	else
		printf "oda.sh query - Query the database\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh query MODEL [OPTIONS]\n"
	printf "  oda.sh query --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--db_name DATABASE"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "-U USERNAME"
		printf "    Odoo username\n"
		printf "    Default: admin\n"
		echo

		# :flag.usage
		printf "  %s\n" "-P PASSWORD"
		printf "    Odoo password\n"
		printf "    Default: admin\n"
		echo

		# :flag.usage
		printf "  %s\n" "--filter FILTER"
		printf "    Model domain filter\n"
		printf "    Default: \n"
		echo

		# :flag.usage
		printf "  %s\n" "--fields FIELDS"
		printf "    Model fields to show\n"
		echo

		# :flag.usage
		printf "  %s\n" "--limit LIMIT"
		printf "    Limit on records returned\n"
		echo

		# :flag.usage
		printf "  %s\n" "--offset OFFSET"
		printf "    Offset of records returned\n"
		echo

		# :flag.usage
		printf "  %s\n" "--count"
		printf "    Count matching records\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "MODEL"
		printf "    odoo model to be queried\n"
		echo

	fi
}

# :command.usage
oda.sh_backup_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh backup - Backup database filestore and addons\n"
		echo

	else
		printf "oda.sh backup - Backup database filestore and addons\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh backup\n"
	printf "  oda.sh backup --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda backup\n"
		echo

	fi
}

# :command.usage
oda.sh_restore_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh restore - Restore database and filestore or addons\n"
		echo

	else
		printf "oda.sh restore - Restore database and filestore or addons\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh restore FILE...\n"
	printf "  oda.sh restore --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "FILE..."
		printf "    Path to backup file\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda restore backups/2020_01_01_12_00_01_odoo.zip\n"
		printf "  oda restore backups/2020_01_01_12_00_01_odoo_addons-custom.zip\n"
		printf "  oda restore backups/2020_01_01_12_00_01_odoo.zip\n  backups/2020_01_01_12_00_01_odoo_addons-custom.zip\n"
		echo

	fi
}

# :command.usage
oda.sh_admin_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh admin - Admin user management\n"
		echo

	else
		printf "oda.sh admin - Admin user management\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh admin [OPTIONS] COMMAND\n"
	printf "  oda.sh admin [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Odoo Admin username\n" "user    "
	printf "  %s   Odoo Admin password\n" "password"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--host HOST"
		printf "    Database Host\n"
		printf "    Default: $(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--port PORT"
		printf "    Database Port\n"
		printf "    Default: $(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--db_user DB_USERNAME"
		printf "    Username\n"
		printf "    Default: $(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--db_pass DB_PASS"
		printf "    Password\n"
		printf "    Default: $(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--db_name DB_NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_admin_user_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh admin user - Odoo Admin username\n"
		echo

	else
		printf "oda.sh admin user - Odoo Admin username\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh admin user [ADMIN_NAME]\n"
	printf "  oda.sh admin user --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "ADMIN_NAME"
		printf "    Odoo Admin username\n"
		echo

	fi
}

# :command.usage
oda.sh_admin_password_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh admin password - Odoo Admin password\n"
		echo

	else
		printf "oda.sh admin password - Odoo Admin password\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh admin password ADMIN_PASSWORD\n"
	printf "  oda.sh admin password --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "ADMIN_PASSWORD"
		printf "    Odoo Admin password\n"
		echo

	fi
}

# :command.usage
oda.sh_project_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh project - Project level commands [CAUTION]\n"
		echo

	else
		printf "oda.sh project - Project level commands [CAUTION]\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh project COMMAND\n"
	printf "  oda.sh project [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Create a new project specifying Odoo version, Odoo Port, PostgreSQL port\n" "init   "
	printf "  %s   branch a project from git repository and setup for dev environ\n" "branch "
	printf "  %s   Drop database and filestore [CAUTION]\n" "reset  "
	printf "  %s   Fully destroy the project and all its files [CAUTION]\n" "destroy"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_environment_variables
		printf "%s\n" "Environment Variables:"

		# :environment_variable.usage
		printf "  %s\n" "ODOOBASE"
		printf "\n"
		printf "    Default: ${HOME}/workspace/repos/odoo\n"
		echo

	fi
}

# :command.usage
oda.sh_project_init_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh project init - Create a new project specifying Odoo version, Odoo Port, PostgreSQL port\n"
		echo

	else
		printf "oda.sh project init - Create a new project specifying Odoo version, Odoo Port, PostgreSQL port\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh project init VERSION PROJECTNAME [OPORT] [PGPORT]\n"
	printf "  oda.sh project init --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "    name of the project\n"
		echo

		# :argument.usage
		printf "  %s\n" "OPORT"
		printf "    Odoo Port\n"
		printf "    Default: 8069\n"
		echo

		# :argument.usage
		printf "  %s\n" "PGPORT"
		printf "    PostgreSQL Port\n"
		printf "    Default: 5432\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda project init 16\n"
		printf "  oda project init 16 8080\n"
		printf "  oda project init 16 8080 5444\n"
		echo

	fi
}

# :command.usage
oda.sh_project_branch_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh project branch - branch a project from git repository and setup for dev environ\n"
		echo

	else
		printf "oda.sh project branch - branch a project from git repository and setup for dev environ\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh project branch VERSION PROJECTNAME BRANCH URL [OPORT] [PGPORT]\n"
	printf "  oda.sh project branch --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "    name of the project\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "    branch to pull from the repository\n"
		echo

		# :argument.usage
		printf "  %s\n" "URL"
		printf "    url of the repository\n"
		echo

		# :argument.usage
		printf "  %s\n" "OPORT"
		printf "    Odoo Port\n"
		printf "    Default: 8069\n"
		echo

		# :argument.usage
		printf "  %s\n" "PGPORT"
		printf "    PostgreSQL Port\n"
		printf "    Default: 5432\n"
		echo

	fi
}

# :command.usage
oda.sh_project_reset_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh project reset - Drop database and filestore [CAUTION]\n"
		echo

	else
		printf "oda.sh project reset - Drop database and filestore [CAUTION]\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh project reset [OPTIONS]\n"
	printf "  oda.sh project reset --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--host HOST"
		printf "    Database Host\n"
		printf "    Default: $(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--port PORT"
		printf "    Database Port\n"
		printf "    Default: $(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--user USERNAME"
		printf "    Username\n"
		printf "    Default: $(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--pass PASS"
		printf "    Password\n"
		printf "    Default: $(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--name NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda project reset\n"
		echo

	fi
}

# :command.usage
oda.sh_project_destroy_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh project destroy - Fully destroy the project and all its files [CAUTION]\n"
		echo

	else
		printf "oda.sh project destroy - Fully destroy the project and all its files [CAUTION]\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh project destroy [OPTIONS]\n"
	printf "  oda.sh project destroy --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--host HOST"
		printf "    Database Host\n"
		printf "    Default: $(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--port PORT"
		printf "    Database Port\n"
		printf "    Default: $(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--user USERNAME"
		printf "    Username\n"
		printf "    Default: $(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--pass PASS"
		printf "    Password\n"
		printf "    Default: $(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--name NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda project destroy\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo - Odoo community and enterprise repository management\n"
		echo

	else
		printf "oda.sh repo - Odoo community and enterprise repository management\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo COMMAND\n"
	printf "  oda.sh repo [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   manage the Odoo base source repository\n" "base   "
	printf "  %s   manage the Odoo branch version repository\n" "version"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_environment_variables
		printf "%s\n" "Environment Variables:"

		# :environment_variable.usage
		printf "  %s\n" "ODOOBASE"
		printf "\n"
		printf "    Default: ${HOME}/workspace/repos/odoo\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_base_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo base - manage the Odoo base source repository\n"
		echo

	else
		printf "oda.sh repo base - manage the Odoo base source repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo base COMMAND\n"
	printf "  oda.sh repo base [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   clone the Odoo source repository\n" "clone "
	printf "  %s   update the Odoo source repository\n" "update"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_base_clone_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo base clone - clone the Odoo source repository\n"
		echo

	else
		printf "oda.sh repo base clone - clone the Odoo source repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo base clone\n"
	printf "  oda.sh repo base clone --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_base_update_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo base update - update the Odoo source repository\n"
		echo

	else
		printf "oda.sh repo base update - update the Odoo source repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo base update\n"
	printf "  oda.sh repo base update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_version_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo version - manage the Odoo branch version repository\n"
		echo

	else
		printf "oda.sh repo version - manage the Odoo branch version repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo version COMMAND\n"
	printf "  oda.sh repo version [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   clone Odoo version repository\n" "clone "
	printf "  %s   update Odoo version repository\n" "update"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_version_clone_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo version clone - clone Odoo version repository\n"
		echo

	else
		printf "oda.sh repo version clone - clone Odoo version repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo version clone VERSION\n"
	printf "  oda.sh repo version clone --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		echo

	fi
}

# :command.usage
oda.sh_repo_version_update_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh repo version update - update Odoo version repository\n"
		echo

	else
		printf "oda.sh repo version update - update Odoo version repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh repo version update VERSION\n"
	printf "  oda.sh repo version update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		echo

	fi
}

# :command.usage
oda.sh_node_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node - node management commands\n"
		echo

	else
		printf "oda.sh node - node management commands\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node COMMAND\n"
	printf "  oda.sh node [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   start odoo server\n" "start       "
	printf "  %s   stop odoo server\n" "stop        "
	printf "  %s   restart odoo server\n" "restart     "
	printf "  %s   tail the logs\n" "logs        "
	printf "  %s   mount project and odoo to system\n" "mount       "
	printf "  %s   Backup database filestore and addons\n" "backup      "
	printf "  %s   Restore database and filestore or addons\n" "restore     "
	printf "  %s   install requirements to run Odoo (RUN THIS FIRST)\n" "requirements"
	printf "  %s   install systemd startup script\n" "systemd     "
	printf "  %s   direct rsyslog to logger\n" "logger      "
	printf "  %s   manage mounted project\n" "project     "
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_start_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node start - start odoo server\n"
		echo

	else
		printf "oda.sh node start - start odoo server\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node start\n"
	printf "  oda.sh node start --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_stop_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node stop - stop odoo server\n"
		echo

	else
		printf "oda.sh node stop - stop odoo server\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node stop\n"
	printf "  oda.sh node stop --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_restart_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node restart - restart odoo server\n"
		echo

	else
		printf "oda.sh node restart - restart odoo server\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node restart\n"
	printf "  oda.sh node restart --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_logs_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node logs - tail the logs\n"
		echo

	else
		printf "oda.sh node logs - tail the logs\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node logs\n"
	printf "  oda.sh node logs --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_mount_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node mount - mount project and odoo to system\n"
		echo

	else
		printf "oda.sh node mount - mount project and odoo to system\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node mount VERSION PROJECTNAME BRANCH\n"
	printf "  oda.sh node mount --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "    Odoo Project\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "    branch to pull from the repository\n"
		echo

	fi
}

# :command.usage
oda.sh_node_backup_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node backup - Backup database filestore and addons\n"
		echo

	else
		printf "oda.sh node backup - Backup database filestore and addons\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node backup\n"
	printf "  oda.sh node backup --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_examples
		printf "%s\n" "Examples:"
		printf "  oda backup\n"
		echo

	fi
}

# :command.usage
oda.sh_node_restore_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node restore - Restore database and filestore or addons\n"
		echo

	else
		printf "oda.sh node restore - Restore database and filestore or addons\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node restore FILE... [OPTIONS]\n"
	printf "  oda.sh node restore --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--remote"
		printf "\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "FILE..."
		printf "    Path to backup file\n"
		echo

	fi
}

# :command.usage
oda.sh_node_requirements_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node requirements - install requirements to run Odoo (RUN THIS FIRST)\n"
		echo

	else
		printf "oda.sh node requirements - install requirements to run Odoo (RUN THIS FIRST)\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node requirements FSIP DBIP LOGGERIP\n"
	printf "  oda.sh node requirements --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "FSIP"
		printf "    Odoo FS server IP address\n"
		echo

		# :argument.usage
		printf "  %s\n" "DBIP"
		printf "    Odoo DB server IP address\n"
		echo

		# :argument.usage
		printf "  %s\n" "LOGGERIP"
		printf "    Log server IP address\n"
		echo

	fi
}

# :command.usage
oda.sh_node_systemd_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node systemd - install systemd startup script\n"
		echo

	else
		printf "oda.sh node systemd - install systemd startup script\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node systemd\n"
	printf "  oda.sh node systemd --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_logger_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node logger - direct rsyslog to logger\n"
		echo

	else
		printf "oda.sh node logger - direct rsyslog to logger\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node logger\n"
	printf "  oda.sh node logger --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_project_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node project - manage mounted project\n"
		echo

	else
		printf "oda.sh node project - manage mounted project\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node project COMMAND\n"
	printf "  oda.sh node project [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Drop database and filestore [CAUTION]\n" "reset"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_node_project_reset_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh node project reset - Drop database and filestore [CAUTION]\n"
		echo

	else
		printf "oda.sh node project reset - Drop database and filestore [CAUTION]\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh node project reset [OPTIONS]\n"
	printf "  oda.sh node project reset --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_flags
		# :flag.usage
		printf "  %s\n" "--host HOST"
		printf "    Database Host\n"
		printf "    Default: $(grep db_host /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--port PORT"
		printf "    Database Port\n"
		printf "    Default: $(grep db_port /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--user USERNAME"
		printf "    Username\n"
		printf "    Default: $(grep db_user /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--pass PASS"
		printf "    Password\n"
		printf "    Default: $(grep db_pass /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :flag.usage
		printf "  %s\n" "--name NAME"
		printf "    Database Name\n"
		printf "    Default: $(grep db_name /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')\n"
		echo

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs - odoofs server management commands\n"
		echo

	else
		printf "oda.sh fs - odoofs server management commands\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs COMMAND\n"
	printf "  oda.sh fs [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   Odoo community and enterprise repository management\n" "odoo   "
	printf "  %s   project repo management\n" "project"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_odoo_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs odoo - Odoo community and enterprise repository management\n"
		echo

	else
		printf "oda.sh fs odoo - Odoo community and enterprise repository management\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs odoo COMMAND\n"
	printf "  oda.sh fs odoo [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   initialize Odoo source repository\n" "init  "
	printf "  %s   update Odoo source repository\n" "update"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_odoo_init_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs odoo init - initialize Odoo source repository\n"
		echo

	else
		printf "oda.sh fs odoo init - initialize Odoo source repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs odoo init VERSION\n"
	printf "  oda.sh fs odoo init --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_odoo_update_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs odoo update - update Odoo source repository\n"
		echo

	else
		printf "oda.sh fs odoo update - update Odoo source repository\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs odoo update VERSION\n"
	printf "  oda.sh fs odoo update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_project_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs project - project repo management\n"
		echo

	else
		printf "oda.sh fs project - project repo management\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs project COMMAND\n"
	printf "  oda.sh fs project [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   project folder setup\n" "init  "
	printf "  %s   pull from git latest project code\n" "update"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_project_init_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs project init - project folder setup\n"
		echo

	else
		printf "oda.sh fs project init - project folder setup\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs project init VERSION PROJECTNAME BRANCH PROJECTURL\n"
	printf "  oda.sh fs project init --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "    Odoo Version\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "    Odoo Project\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "    Project Branch\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTURL"
		printf "    Odoo Project Git URL\n"
		echo

	fi
}

# :command.usage
oda.sh_fs_project_update_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh fs project update - pull from git latest project code\n"
		echo

	else
		printf "oda.sh fs project update - pull from git latest project code\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh fs project update PROJECTNAME BRANCH\n"
	printf "  oda.sh fs project update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "    Odoo Project\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "    Project Branch\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote - manage remote servers via ssh commands\n"
		echo

	else
		printf "oda.sh remote - manage remote servers via ssh commands\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote COMMAND\n"
	printf "  oda.sh remote [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   manage odoo repositories on odoofs\n" "odoo   "
	printf "  %s   manage project code on odoofs\n" "project"
	printf "  %s   backup project on target node\n" "backup "
	printf "  %s   mounts project on target node\n" "restore"
	printf "  %s   mounts project on target node\n" "mount  "
	printf "  %s   start odoo service on target node\n" "start  "
	printf "  %s   stop odoo service on target node\n" "stop   "
	printf "  %s   restart odoo service on target node\n" "restart"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_odoo_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote odoo - manage odoo repositories on odoofs\n"
		echo

	else
		printf "oda.sh remote odoo - manage odoo repositories on odoofs\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote odoo COMMAND\n"
	printf "  oda.sh remote odoo [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   pull latest odoo code\n" "update"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_odoo_update_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote odoo update - pull latest odoo code\n"
		echo

	else
		printf "oda.sh remote odoo update - pull latest odoo code\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote odoo update VERSION [REMOTE]\n"
	printf "  oda.sh remote odoo update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "REMOTE"
		printf "\n"
		printf "    Default: odoofs\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_project_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote project - manage project code on odoofs\n"
		echo

	else
		printf "oda.sh remote project - manage project code on odoofs\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote project COMMAND\n"
	printf "  oda.sh remote project [COMMAND] --help | -h\n"
	echo
	# :command.usage_commands
	printf "%s\n" "Commands:"
	printf "  %s   initialize the project and git clone from project repo\n" "init  "
	printf "  %s   git pull update from project repo\n" "update"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_project_init_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote project init - initialize the project and git clone from project repo\n"
		echo

	else
		printf "oda.sh remote project init - initialize the project and git clone from project repo\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote project init VERSION PROJECTNAME BRANCH PROJECTURL [REMOTE]\n"
	printf "  oda.sh remote project init --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTURL"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "REMOTE"
		printf "\n"
		printf "    Default: odoofs\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_project_update_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote project update - git pull update from project repo\n"
		echo

	else
		printf "oda.sh remote project update - git pull update from project repo\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote project update PROJECTNAME BRANCH [REMOTE]\n"
	printf "  oda.sh remote project update --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "REMOTE"
		printf "\n"
		printf "    Default: odoofs\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_backup_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote backup - backup project on target node\n"
		echo

	else
		printf "oda.sh remote backup - backup project on target node\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote backup NODE\n"
	printf "  oda.sh remote backup --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NODE"
		printf "\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_restore_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote restore - mounts project on target node\n"
		echo

	else
		printf "oda.sh remote restore - mounts project on target node\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote restore NODE FILE...\n"
	printf "  oda.sh remote restore --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NODE"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "FILE..."
		printf "    Path to backup file\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_mount_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote mount - mounts project on target node\n"
		echo

	else
		printf "oda.sh remote mount - mounts project on target node\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote mount NODE VERSION PROJECTNAME BRANCH\n"
	printf "  oda.sh remote mount --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NODE"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "VERSION"
		printf "\n"
		printf "    Allowed: 15, 16, 17\n"
		echo

		# :argument.usage
		printf "  %s\n" "PROJECTNAME"
		printf "\n"
		echo

		# :argument.usage
		printf "  %s\n" "BRANCH"
		printf "\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_start_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote start - start odoo service on target node\n"
		echo

	else
		printf "oda.sh remote start - start odoo service on target node\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote start NODE\n"
	printf "  oda.sh remote start --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NODE"
		printf "\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_stop_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote stop - stop odoo service on target node\n"
		echo

	else
		printf "oda.sh remote stop - stop odoo service on target node\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote stop NODE\n"
	printf "  oda.sh remote stop --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NODE"
		printf "\n"
		echo

	fi
}

# :command.usage
oda.sh_remote_restart_usage() {
	if [[ -n $long_usage ]]; then
		printf "oda.sh remote restart - restart odoo service on target node\n"
		echo

	else
		printf "oda.sh remote restart - restart odoo service on target node\n"
		echo

	fi

	printf "%s\n" "Usage:"
	printf "  oda.sh remote restart NODE\n"
	printf "  oda.sh remote restart --help | -h\n"
	echo

	# :command.long_usage
	if [[ -n $long_usage ]]; then
		printf "%s\n" "Options:"

		# :command.usage_fixed_flags
		printf "  %s\n" "--help, -h"
		printf "    Show this help\n"
		echo

		# :command.usage_args
		printf "%s\n" "Arguments:"

		# :argument.usage
		printf "  %s\n" "NODE"
		printf "\n"
		echo

	fi
}

# :command.normalize_input
normalize_input() {
	local arg flags

	while [[ $# -gt 0 ]]; do
		arg="$1"
		if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
			input+=("${BASH_REMATCH[1]}")
			input+=("${BASH_REMATCH[2]}")
		elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
			flags="${BASH_REMATCH[1]}"
			for ((i = 0; i < ${#flags}; i++)); do
				input+=("-${flags:i:1}")
			done
		else
			input+=("$arg")
		fi

		shift
	done
}
# :command.inspect_args
inspect_args() {
	if ((${#args[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
		echo args:
		for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
	else
		echo args: none
	fi

	if ((${#other_args[@]})); then
		echo
		echo other_args:
		echo "- \${other_args[*]} = ${other_args[*]}"
		for i in "${!other_args[@]}"; do
			echo "- \${other_args[$i]} = ${other_args[$i]}"
		done
	fi

	if ((${#deps[@]})); then
		readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
		echo
		echo deps:
		for k in "${sorted_keys[@]}"; do echo "- \${deps[$k]} = ${deps[$k]}"; done
	fi

}

# :command.command_functions

# :command.function
oda.sh_config_vscode_command() {
	# src/config_vscode_command.sh
	if [ -z $ODOO_PORT ]; then
		if [[ -f ".envrc" ]]; then
			export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
		else
			export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
		fi
	fi

	function launch_json(){
	[ -z ${2} ] && export PORT=8069 || export PORT=${2}
	cat <<-_EOF_ | tee .vscode/launch.json > /dev/null
	{
		"version": "0.2.0",
		"configurations": [
			{
				"name": "Launch",
				"type": "python",
				"request": "launch",
				"stopOnEntry": false,
				"python": "\${command:python.interpreterPath}",
				"program": "\${workspaceRoot}/odoo/odoo-bin",
				"args": ["-c", "\${workspaceRoot}/conf/odoo.conf","-p","$ODOO_PORT"],
				"cwd": "\${workspaceRoot}",
				"env": {},
				"envFile": "\${workspaceFolder}/.env",
				"console": "integratedTerminal"
			}
		]
	}
	_EOF_
	}

	function settings_json(){
	[ -z ${2} ] && export PORT=8069 || export PORT=${2}
	cat <<-_EOF_ | tee .vscode/settings.json > /dev/null
	{
		"python.analysis.extraPaths": ["odoo", "enterprise"],
		"python.linting.pylintEnabled": true,
		"python.linting.enabled": true,
		"python.terminal.executeInFileDir": true,
		"python.formatting.provider": "black"
	}
	_EOF_
	}

	mkdir -p .vscode
	settings_json
	launch_json
}

# :command.function
oda.sh_config_pyright_command() {
	# src/config_pyright_command.sh
	[ -z ${ODOO_C} ] && export ODOO_C="odoo"
	[ -z ${ODOO_E} ] && export ODOO_E="enterprise"

	cat <<-_EOF_ | tee pyrightconfig.json > /dev/null
	{
		"venvPath": ".",
		"venv": ".direnv",
		"executionEnvironments": [
			{
				"root": ".",
				"extraPaths": [
					"${ODOO_C}",
					"${ODOO_E}",
					"addons"
					]
			}
		]
	}
	_EOF_

}

# :command.function
oda.sh_start_command() {
	# src/start_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z $ODOO_PORT ]; then
			if [[ -f ".envrc" ]]; then
				export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
			else
				export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
			fi
		fi
		truncate -s 0 odoo.log
		nohup ../${POD}/odoo/odoo-bin -c conf/odoo.conf --http-port ${ODOO_PORT} > /dev/null 2>&1 & disown
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_stop_command() {
	# src/stop_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		pkill -f "${POD}/odoo/odoo-bin"
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_restart_command() {
	# src/restart_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z $ODOO_PORT ]; then
			if [[ -f ".envrc" ]]; then
				export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
			else
				export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
			fi
		fi
		pkill -f "${POD}/odoo/odoo-bin"
		sleep 2
		truncate -s 0 odoo.log
		nohup ../${POD}/odoo/odoo-bin -c conf/odoo.conf --http-port ${ODOO_PORT} > /dev/null 2>&1 & disown
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_logs_command() {
	# src/logs_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		LOG=$(grep logfile ./conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
		tail -f ${LOG}
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_scaffold_command() {
	# src/scaffold_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		../${POD}/odoo/odoo-bin scaffold ${args[module]} ../${POD}/addons/.
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_init_command() {
	# src/init_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z $ODOO_PORT ]; then
			if [[ -f ".envrc" ]]; then
				export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
			else
				export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
			fi
		fi
		odoo/odoo-bin -c conf/odoo.conf --no-http --stop-after-init -d ${args[--name]} -i ${args[modules]}
		pkill -f "${POD}/odoo/odoo-bin"
		sleep 2
		truncate -s 0 odoo.log
		nohup ../${POD}/odoo/odoo-bin -c conf/odoo.conf --http-port ${ODOO_PORT} > /dev/null 2>&1 & disown
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_install_command() {
	# src/install_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z $ODOO_PORT ]; then
			if [[ -f ".envrc" ]]; then
				export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
			else
				export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
			fi
		fi
		odoo/odoo-bin -c conf/odoo.conf --no-http --stop-after-init -d ${args[--name]} -i ${args[modules]}
		pkill -f "${POD}/odoo/odoo-bin"
		sleep 2
		truncate -s 0 odoo.log
		nohup ../${POD}/odoo/odoo-bin -c conf/odoo.conf --http-port ${ODOO_PORT} > /dev/null 2>&1 & disown
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_upgrade_command() {
	# src/upgrade_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z $ODOO_PORT ]; then
			if [[ -f ".envrc" ]]; then
				export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
			else
				export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
			fi
		fi
		odoo/odoo-bin -c conf/odoo.conf --no-http --stop-after-init -d ${args[--name]} -u ${args[modules]}
		pkill -f "${POD}/odoo/odoo-bin"
		sleep 2
		truncate -s 0 odoo.log
		nohup ../${POD}/odoo/odoo-bin -c conf/odoo.conf --http-port ${ODOO_PORT} > /dev/null 2>&1 & disown
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_manifest_export_command() {
	# src/manifest_export_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		BASE=`dirname "${0}"`
		python3 -B ${BASE}/oda_db.py -e
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_manifest_import_command() {
	# src/manifest_import_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		BASE=`dirname "${0}"`
		python3 -B ${BASE}/oda_db.py -i
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_manifest_remote_command() {
	# src/manifest_remote_command.sh
	REMOTE_FS=odoofs
	ssh ${REMOTE_FS} tar Oaxf /share/${args[file]} ./manifest.json > manifest.json
}

# :command.function
oda.sh_psql_command() {
	# src/psql_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		psql postgres://${args[--user]}:${args[--pass]}@${args[--host]}:${args[--port]}/${args[--name]}
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_query_command() {
	# src/query_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z $ODOO_PORT ]; then
			if [[ -f ".envrc" ]]; then
				export ODOO_PORT=$(grep ODOO_PORT .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
			else
				export ODOO_PORT=$(grep http_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')
			fi
		fi

		EXEC="odooquery -host localhost -port ${ODOO_PORT} -d ${args[--db_name]} -U ${args[-U]} -P ${args[-P]} -model ${args[model]}"
		[ -z ${args[--filter]} ] || EXEC="${EXEC} -filter \"${args[--filter]}\""
		[ -z ${args[--fields]} ] || EXEC="${EXEC} -fields ${args[--fields]}"
		[ -z ${args[--limit]} ] || EXEC="${EXEC} -limit ${args[--limit]}"
		[ -z ${args[--offset]} ] || EXEC="${EXEC} -offset ${args[--offset]}"
		[ -z ${args[--count]} ] || EXEC="${EXEC} -count"
		${EXEC}
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_backup_command() {
	# src/backup_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		BASE=`dirname "${0}"`
		python3 -B ${BASE}/oda_db.py -b
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_restore_command() {
	# src/restore_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		BASE=`dirname "${0}"`
		for bfile in ${args[file]}
		do
			python3 -B ${BASE}/oda_db.py -r -d "${bfile}"
		done
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_admin_user_command() {
	# src/admin_user_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		if [ -z "${args[admin_name]}" ]; then
			admin_user=$(psql postgres://${args[--db_user]}:${args[--db_pass]}@${args[--host]}:${args[--port]}/${args[--db_name]} -t -c "select login from res_users where id=2;")
			echo "Odoo Admin username: $(echo $admin_user || awk '{print $1}')"
		else
			read -r -p "Are you sure you want to change the admin username to: ${args[admin_name]} [YES/N] " response
			if [[ "$response" =~ ^(YES)$ ]]; then
			echo "changing username to: ${args[admin_name]}"
			admin_user=$(psql postgres://${args[--db_user]}:${args[--db_pass]}@${args[--host]}:${args[--port]}/${args[--db_name]} -t -c "update res_users set login='${args[admin_name]}' where id=2;")
			fi
		fi
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_admin_password_command() {
	# src/admin_password_command.sh
	if [[ -f "./conf/odoo.conf" ]]; then
		read -r -p "Are you sure you want to change the admin password [YES/N] " response
		if [[ "$response" =~ ^(YES)$ ]]; then
			BASE=`dirname "${0}"`
			admin_password=$(python3 -B ${BASE}/oda_db.py -p ${args[admin_password]})
			psql postgres://${args[--db_user]}:${args[--db_pass]}@${args[--host]}:${args[--port]}/${args[--db_name]} -t -c "update res_users set password='${admin_password}' where id=2;" >/dev/null
		fi
	else
		echo "not in a project directory"
	fi
}

# :command.function
oda.sh_project_init_command() {
	# src/project_init_command.sh
	function envrc(){
	[ -z ${2} ] && export PORT=8069 || export PORT=${2}
	cat <<-_EOF_ | tee .envrc > /dev/null
	layout python3
	export ODOO_V=${1}.0
	export ODOO_PORT=${PORT}
	export ODOO_C=${ODOOBASE}/${1}.0/odoo
	export ODOO_E=${ODOOBASE}/${1}.0/enterprise
	_EOF_
	}

	function configfile(){
	cat <<-_EOF_ | tee conf/odoo.conf > /dev/null
	[options]
	addons_path = ./odoo/addons,./enterprise,./addons
	admin_passwd = adminadmin
	without_demo = all
	csv_internal_sep = ;
	data_dir = ./data
	db_host = ${IPV4}
	db_port = 5432
	db_maxconn = 24
	db_user = odoo${1}
	db_password = odooodoo
	db_name = ${2}
	db_template = template0
	db_sslmode = disable
	list_db = False
	workers = 0
	#max_cron_threads = 2
	http_enable = True
	http_interface =
	http_port = 8069
	reportgz = False
	server_wide_modules = base,web
	logfile = ./odoo.log
	log_level = debug
	logrotate = True
	# log_handler = werkzeug:CRITICAL,odoo.api:DEBUG
	# log_db_level = warning
	_EOF_
	}

	function pipfile(){
	cat <<-_EOF_ | tee Pipfile > /dev/null
	[[source]]
	url = "https://pypi.org/simple"
	verify_ssl = true
	name = "pypi"

	[packages]
	babel = "==2.9.1"
	chardet = "==3.0.4"
	cryptography = "==2.6.1"
	decorator = "==4.4.2"
	docutils = "==0.16"
	ebaysdk = "==2.1.5"
	freezegun = "==0.3.15"
	gevent = "==21.8.0"
	google-auth = "==2.17.*"
	greenlet = "==1.1.*"
	idna = "==2.8"
	jinja2 = "==2.11.3"
	libsass = "==0.18.0"
	lxml = "==4.6.5"
	markupsafe = "==1.1.0"
	num2words = "==0.5.6"
	ofxparse = "==0.21"
	passlib = "==1.7.3"
	pillow = "==9.0.1"
	polib = "==1.1.0"
	"pdfminer.six" = "*"
	psutil = "==5.6.7"
	psycopg2-binary = "2.9.5"
	pydot = "==1.4.1"
	pyopenssl = "==19.0.0"
	pypdf2 = "==1.26.0"
	pyserial = "==3.4"
	python-dateutil = "==2.8.2"
	python-stdnum = "==1.13"
	pytz = "*"
	pyusb = "==1.0.2"
	qrcode = "==6.1"
	reportlab = "==3.5.59"
	requests = "==2.25.1"
	rjsmin = "==1.1.0"
	urllib3 = "==1.26.5"
	vobject = "==0.9.6.1"
	werkzeug = "==2.0.3"
	xlrd = "==1.2.0"
	xlsxwriter = "==1.1.2"
	xlwt = "==1.3.*"
	zeep = "==3.4.0"
	paramiko = "==2.12.0"

	[dev-packages]
	black="*"
	yapf="*"
	pylint="*"
	pylint-odoo="*"

	[requires]
	python_version = "3"
	_EOF_
	}

	PDIR=${HOME}/workspace/odoo/${args[projectname]}
	mkdir -p ${PDIR}
	cd ${PDIR}
	envrc ${args[version]} ${args[oport]}
	direnv allow >/dev/null
	mkdir -p conf data backups addons
	ODOO_C=$(grep ODOO_C .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
	ODOO_E=$(grep ODOO_E .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
	if [ -L "odoo" ]; then rm -f odoo ; fi
	ln -f -s ${ODOO_C} odoo
	if [ -L "enterprise" ]; then rm -f enterprise ; fi
	ln -f -s ${ODOO_E} enterprise
	configfile ${args[version]} ${args[projectname]}
	pipfile
	printf "To install python dev dependencies run:\npipenv install --dev\n\n"
}

# :command.function
oda.sh_project_branch_command() {
	# src/project_branch_command.sh
	function envrc(){
	[ -z ${2} ] && export PORT=8069 || export PORT=${2}
	cat <<-_EOF_ | tee .envrc > /dev/null
	layout python3
	export ODOO_V=${1}.0
	export ODOO_PORT=${PORT}
	export ODOO_C=${ODOOBASE}/${1}.0/odoo
	export ODOO_E=${ODOOBASE}/${1}.0/enterprise
	_EOF_
	}

	function configfile(){
	cat <<-_EOF_ | tee conf/odoo.conf > /dev/null
	[options]
	addons_path = ./odoo/addons,./enterprise,./addons
	admin_passwd = adminadmin
	without_demo = all
	csv_internal_sep = ;
	data_dir = ./data
	db_host = ${IPV4}
	db_port = 5432
	db_maxconn = 24
	db_user = odoo${1}
	db_password = odooodoo
	db_name = ${2}
	db_template = template0
	db_sslmode = disable
	list_db = False
	workers = 0
	#max_cron_threads = 2
	http_enable = True
	http_interface =
	http_port = 8069
	reportgz = False
	server_wide_modules = base,web
	logfile = ./odoo.log
	log_level = debug
	logrotate = True
	# log_handler = werkzeug:CRITICAL,odoo.api:DEBUG
	# log_db_level = warning
	_EOF_
	}

	function pipfile(){
	cat <<-_EOF_ | tee Pipfile > /dev/null
	[[source]]
	url = "https://pypi.org/simple"
	verify_ssl = true
	name = "pypi"

	[packages]
	babel = "==2.9.1"
	chardet = "==3.0.4"
	cryptography = "==2.6.1"
	decorator = "==4.4.2"
	docutils = "==0.16"
	ebaysdk = "==2.1.5"
	freezegun = "==0.3.15"
	gevent = "==21.8.0"
	google-auth = "==2.17.*"
	greenlet = "==1.1.*"
	idna = "==2.8"
	jinja2 = "==2.11.3"
	libsass = "==0.18.0"
	lxml = "==4.6.5"
	markupsafe = "==1.1.0"
	num2words = "==0.5.6"
	ofxparse = "==0.21"
	passlib = "==1.7.3"
	pillow = "==9.0.1"
	polib = "==1.1.0"
	"pdfminer.six" = "*"
	psutil = "==5.6.7"
	psycopg2-binary = "2.9.5"
	pydot = "==1.4.1"
	pyopenssl = "==19.0.0"
	pypdf2 = "==1.26.0"
	pyserial = "==3.4"
	python-dateutil = "==2.8.2"
	python-stdnum = "==1.13"
	pytz = "*"
	pyusb = "==1.0.2"
	qrcode = "==6.1"
	reportlab = "==3.5.59"
	requests = "==2.25.1"
	rjsmin = "==1.1.0"
	urllib3 = "==1.26.5"
	vobject = "==0.9.6.1"
	werkzeug = "==2.0.3"
	xlrd = "==1.2.0"
	xlsxwriter = "==1.1.2"
	xlwt = "==1.3.*"
	zeep = "==3.4.0"
	paramiko = "==2.12.0"

	[dev-packages]
	black="*"
	yapf="*"
	pylint="*"
	pylint-odoo="*"

	[requires]
	python_version = "3"
	_EOF_
	}

	PDIR=${HOME}/workspace/odoo/${args[projectname]}_${args[branch]}
	mkdir -p ${PDIR}
	cd ${PDIR}
	envrc ${args[version]} ${args[oport]}
	direnv allow >/dev/null
	mkdir -p conf data backups
	git clone ${args[url]} -b ${args[branch]} addons
	ODOO_C=$(grep ODOO_C .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
	ODOO_E=$(grep ODOO_E .envrc | awk '{print $2}' | awk -F'=' '{print $2}')
	if [ -L "odoo" ]; then rm -f odoo ; fi
	ln -f -s ${ODOO_C} odoo
	if [ -L "enterprise" ]; then rm -f enterprise ; fi
	ln -f -s ${ODOO_E} enterprise
	configfile ${args[version]} ${args[projectname]}_${args[branch]}
	pipfile
	printf "To install python dev dependencies run:\npipenv install --dev\n\n"
}

# :command.function
oda.sh_project_reset_command() {
	# src/project_reset_command.sh
	read -r -p "Are you sure you want to reset the database? [YES/N] " response
	if [[ "$response" =~ ^(YES)$ ]]; then
		read -r -p "Are you **really** sure you want to reset the database? [YES/N] " response
		if [[ "$response" =~ ^(YES)$ ]]; then
			echo "Resetting project"
			trap "pkill -f ${POD}/odoo/odoo-bin" SIGINT
			rm -rf data/* > /dev/null
			PGPASSWORD=${args[--pass]} dropdb -U ${args[--user]} -h ${args[--host]} -p ${args[--port]} -w -f ${args[--name]} >/dev/null
			echo "Project reset"
		fi
	fi
}

# :command.function
oda.sh_project_destroy_command() {
	# src/project_destroy_command.sh
	read -r -p "Are you sure you want to destroy everything? [YES/N] " response
	if [[ "$response" =~ ^(YES)$ ]]; then
		read -r -p "Are you **really** sure you want to destroy everything? [YES/N] " response
		if [[ "$response" =~ ^(YES)$ ]]; then
			echo "Destroying project"
			trap "pkill -f ${POD}/odoo/odoo-bin" SIGINT
			rm -rf .direnv/ .envrc *
			PGPASSWORD=${args[--pass]} dropdb -U ${args[--user]} -h ${args[--host]} -p ${args[--port]} -w -f ${args[--name]} >/dev/null
			echo "Project has been destroyed"
		fi
	fi
}

# :command.function
oda.sh_repo_base_clone_command() {
	# src/repo_base_clone_command.sh
	git clone https://github.com/odoo/odoo ${ODOOBASE}/odoo
	git clone https://github.com/odoo/enterprise ${ODOOBASE}/enterprise
}

# :command.function
oda.sh_repo_base_update_command() {
	# src/repo_base_update_command.sh
	cd ${ODOOBASE}/odoo/
	git fetch origin && git checkout $(git branch -a | grep HEAD | awk '{print $3}' | awk -F'/' '{print $2}') && git pull

	cd ${ODOOBASE}/enterprise/
	git fetch origin && git checkout $(git branch -a | grep HEAD | awk '{print $3}' | awk -F'/' '{print $2}') && git pull

}

# :command.function
oda.sh_repo_version_clone_command() {
	# src/repo_version_clone_command.sh
	mkdir -p ${ODOOBASE}/${args[version]}
	rsync -at --inplace --delete ${ODOOBASE}/odoo/ ${ODOOBASE}/${args[version]}/odoo/
	rsync -at --inplace --delete ${ODOOBASE}/enterprise/ ${ODOOBASE}/${args[version]}/enterprise/

	cd ${ODOOBASE}/${args[version]}/odoo/
	git fetch origin && git checkout ${args[version]} && git pull

	cd ${ODOOBASE}/${args[version]}/enterprise/
	git fetch origin && git checkout ${args[version]} && git pull
}

# :command.function
oda.sh_repo_version_update_command() {
	# src/repo_version_update_command.sh
	cd ${ODOOBASE}/${args[version]}/odoo/
	git fetch origin && git checkout ${args[version]} && git pull

	cd ${ODOOBASE}/${args[version]}/enterprise/
	git fetch origin && git checkout ${args[version]} && git pull
}

# :command.function
oda.sh_node_start_command() {
	# src/node_start_command.sh
	sudo systemctl start odoo.service
}

# :command.function
oda.sh_node_stop_command() {
	# src/node_stop_command.sh
	sudo systemctl stop odoo.service
}

# :command.function
oda.sh_node_restart_command() {
	# src/node_restart_command.sh
	sudo systemctl restart odoo.service
}

# :command.function
oda.sh_node_logs_command() {
	# src/node_logs_command.sh
	bash -c 'tail -f /var/log/syslog | grep "Odoo Server"'
}

# :command.function
oda.sh_node_mount_command() {
	# src/node_mount_command.sh
	BASE=/opt/odoo
	BSHARE=/share/backups
	OSHARE=/share/odoo
	PSHARE=/share/projects
	COPTS="rsize=8192,wsize=8192,timeo=15"
	ROPTS="ro,async,noatime"
	WOPTS="rw,sync,relatime"

	# stop odoo service
	sudo systemctl stop odoo.service
	# mkdir mount directories
	sudo bash -c "mkdir -p ${BASE}/{addons,conf,data,backups,odoo,enterprise} && chown odoo:odoo ${BASE}"

	cat <<-_EOF_ | tee /tmp/odoo_fstab > /dev/null
	#BEGINODOO
	odoofs:${BSHARE} ${BASE}/backups nfs4 ${WOPTS},${COPTS} 0 0

	odoofs:${OSHARE}/${args[version]}.0/odoo ${BASE}/odoo nfs4 ${ROPTS},${COPTS} 0 0
	odoofs:${OSHARE}/${args[version]}.0/enterprise ${BASE}/enterprise nfs4 ${ROPTS},${COPTS} 0 0

	odoofs:${PSHARE}/${args[projectname]}/${args[branch]}/addons ${BASE}/addons nfs4 ${ROPTS},${COPTS} 0 0
	odoofs:${PSHARE}/${args[projectname]}/${args[branch]}/conf ${BASE}/conf nfs4 ${ROPTS},${COPTS} 0 0
	odoofs:${PSHARE}/${args[projectname]}/${args[branch]}/data ${BASE}/data nfs4 ${WOPTS},${COPTS} 0 0
	#ENDODOO
	_EOF_

	sudo sed -e '/#BEGINODOO/{:a; N; /\n#ENDODOO$/!ba; r /tmp/odoo_fstab' -e 'd;}' -i /etc/fstab
	sudo rm -f /tmp/odoo_fstab

	sudo umount -R -q ${BASE}/{addons,conf,data,backups,odoo,enterprise}
	sudo mount -a
	# restart odoo service
	sudo systemctl stop odoo.service
}

# :command.function
oda.sh_node_backup_command() {
	# src/node_backup_command.sh
	BASE=/opt/odoo
	cd ${BASE}
	sudo -u odoo python3 -B /usr/local/bin/oda_db.py -b
}

# :command.function
oda.sh_node_restore_command() {
	# src/node_restore_command.sh
	inspect_args
	[[ -z ${args[--remote]} ]] && REMOTE="" || REMOTE="--remote"
	BASE=/opt/odoo
	cd ${BASE}
	for bfile in ${args[file]}
	do
		sudo -u odoo python3 -B /usr/local/bin/oda_db.py ${REMOTE} -r -d "${bfile}"
	done
}

# :command.function
oda.sh_node_requirements_command() {
	# src/node_requirements_command.sh
	sudo bash -c "apt-get update -y"
	sudo apt-get install -y wget git
	REPO="https://github.com/wkhtmltopdf/packaging"
	vers=$(git ls-remote --tags ${REPO} | grep "refs/tags.*[0-9]$" | awk '{print $2}' | sed 's/refs\/tags\///' | sort -V | uniq | tail -1)
	VC=$(grep ^VERSION_CODENAME /etc/os-release | awk -F'=' '{print $2}')
	UC=$(grep ^UBUNTU_CODENAME /etc/os-release | awk -F'=' '{print $2}')
	CN=''
	[ -n "$UC" ] && CN=$UC || CN=$VC
	FN="wkhtmltox_${vers}.${CN}_amd64.deb"

	sudo bash -c "groupadd -f -g 1001 odoo"
	if [ -f $(grep "^odoo:" /etc/passwd) ]; then
		sudo bash -c "useradd -ms /usr/sbin/nologin -g 1001 -u 1001 odoo"
	fi

	# setup fstab
	sudo sed -e '/#BEGINODOO/{:a; N; /\n#ENDODOO$/!ba; echo ""' -e 'd;}' -i /etc/fstab
	echo "#BEGINODOO" | sudo tee -a /etc/fstab
	echo "#ENDODOO" | sudo tee -a /etc/fstab

	# setup hosts cloudinit template
	sudo sed -e '/#BEGINODOO/{:a; N; /\n#ENDODOO$/!ba; echo ""' -e 'd;}' -i /etc/cloud/templates/hosts.debian.tmpl
	echo "#BEGINODOO" | sudo tee -a /etc/cloud/templates/hosts.debian.tmpl
	echo "#ENDODOO" | sudo tee -a /etc/cloud/templates/hosts.debian.tmpl

	cat <<-_EOF_ | tee /tmp/odoo_hosts.debian.tmpl > /dev/null
	#BEGINODOO
	${args[fsip]} odoofs
	${args[dbip]} db
	${args[loggerip]} logger
	#ENDODOO
	_EOF_

	sudo sed -e '/#BEGINODOO/{:a; N; /\n#ENDODOO$/!ba; r /tmp/odoo_hosts.debian.tmpl' -e 'd;}' -i /etc/cloud/templates/hosts.debian.tmpl
	sudo rm -f /tmp/odoo_hosts.debian.tmpl

	# install prerequisites
	sudo bash -c "apt-get update -y"
	sudo apt-get install -y nfs-common qemu-guest-agent

	# PostgreSQL Repo
	sudo wget -qO /etc/apt/trusted.gpg.d/pgdg.gpg.asc https://www.postgresql.org/media/keys/ACCC4CF8.asc
	echo "deb http://apt.postgresql.org/pub/repos/apt/ ${CN}-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list
	sudo bash -c "apt-get update -y"

	# postgresql
	sudo apt-get install -y --no-install-recommends postgresql-client-15

	# install wkhtmltopdf
	wget -qc ${REPO}/releases/download/${vers}/${FN} -O ${HOME}/wkhtmltox.deb
	sudo apt-get install -y --no-install-recommends ${HOME}/wkhtmltox.deb
	rm -rf ${HOME}/wkhtmltox.deb
	sudo bash -c "apt-get update -y"

	# install requirements
	sudo apt-get install -y --no-install-recommends \
			bzip2 \
			ca-certificates \
			curl \
			dirmngr \
			fonts-liberation \
			fonts-noto \
			fonts-noto-cjk \
			fonts-noto-mono \
			geoip-database \
			gnupg \
			gsfonts \
			inetutils-ping \
			libgnutls-dane0 \
			libgts-bin \
			libpaper-utils \
			locales \
			nodejs \
			npm \
			python3 \
			python3-babel \
			python3-chardet \
			python3-cryptography \
			python3-cups \
			python3-dateutil \
			python3-decorator \
			python3-docutils \
			python3-feedparser \
			python3-freezegun \
			python3-geoip2 \
			python3-gevent \
			python3-greenlet \
			python3-html2text \
			python3-idna \
			python3-jinja2 \
			python3-ldap \
			python3-libsass \
			python3-lxml \
			python3-markupsafe \
			python3-num2words \
			python3-ofxparse \
			python3-olefile \
			python3-openssl \
			python3-paramiko \
			python3-passlib \
			python3-pdfminer \
			python3-phonenumbers \
			python3-pil \
			python3-pip \
			python3-polib \
			python3-psutil \
			python3-psycopg2 \
			python3-pydot \
			python3-pylibdmtx \
			python3-pyparsing \
			python3-pypdf2 \
			python3-pytzdata \
			python3-qrcode \
			python3-renderpm \
			python3-reportlab \
			python3-reportlab-accel \
			python3-requests \
			python3-rjsmin \
			python3-serial \
			python3-setuptools \
			python3-stdnum \
			python3-urllib3 \
			python3-usb \
			python3-vobject \
			python3-werkzeug \
			python3-xlrd \
			python3-xlsxwriter \
			python3-xlwt \
			python3-zeep \
			shared-mime-info \
			unzip \
			xz-utils \
			zip

	# install geolite databases
	sudo wget -qO /usr/share/GeoIP/GeoLite2-ASN.mmdb https://github.com/P3TERX/GeoLite.mmdb/raw/download/GeoLite2-ASN.mmdb
	sudo wget -qO /usr/share/GeoIP/GeoLite2-City.mmdb https://github.com/P3TERX/GeoLite.mmdb/raw/download/GeoLite2-City.mmdb
	sudo wget -qO /usr/share/GeoIP/GeoLite2-Country.mmdb https://github.com/P3TERX/GeoLite.mmdb/raw/download/GeoLite2-Country.mmdb

	# install additional python libraries
	#sudo pip install --upgrade pip
	sudo pip3 install --break-system-packages ebaysdk google-auth

	# install additional node libraries
	sudo npm -g i rtlcss

	# update system
	sudo bash -c "apt-get update -y && apt-get dist-upgrade -y && apt-get autoremove -y && apt-get autoclean -y"

	# mkdir mount directories
	sudo bash -c "mkdir -p /opt/odoo/{addons,conf,data,backups,odoo,enterprise} && chown odoo:odoo /opt/odoo"

}

# :command.function
oda.sh_node_systemd_command() {
	# src/node_systemd_command.sh
	function systemd_config(){
	cat <<-_EOF_ | sudo tee /etc/systemd/system/odoo.service > /dev/null
	[Unit]
	Description=Odoo
	After=remote-fs.target

	[Service]
	Type=simple
	SyslogIdentifier=odoo
	PermissionsStartOnly=true
	User=odoo
	Group=odoo
	ExecStart=/opt/odoo/odoo/odoo-bin -c /opt/odoo/conf/odoo.conf
	StandardOutput=journal+console

	[Install]
	WantedBy=remote-fs.target
	_EOF_
	}

	systemd_config
	sudo systemctl daemon-reload
	sudo systemctl enable odoo.service
}

# :command.function
oda.sh_node_logger_command() {
	# src/node_logger_command.sh
	cat <<-_EOF_ | sudo tee /etc/rsyslog.d/99-logger.conf > /dev/null
	*.*;auth,authpriv.none    @logger:514
	_EOF_

	sudo systemctl restart rsyslog.service
}

# :command.function
oda.sh_node_project_reset_command() {
	# src/node_project_reset_command.sh
	BASE=/opt/odoo
	cd ${BASE}
	read -r -p "Are you sure you want to reset the database? [YES/N] " response
	if [[ "$response" =~ ^(YES)$ ]]; then
		read -r -p "Are you **really** sure you want to reset the database? [YES/N] " response
		if [[ "$response" =~ ^(YES)$ ]]; then
			echo "Resetting project"
			sudo systemctl stop odoo.service
			sudo -u odoo rm -rf /opt/odoo/data/* > /dev/null
			PGPASSWORD=${args[--pass]} dropdb -U ${args[--user]} -h ${args[--host]} -p ${args[--port]} -w -f ${args[--name]} >/dev/null
			echo "Project reset"
		fi
	fi
}

# :command.function
oda.sh_fs_odoo_init_command() {
	# src/fs_odoo_init_command.sh
	sudo -u odoo git clone https://github.com/odoo/odoo -b ${args[version]}.0 /share/odoo/${args[version]}.0/odoo
	sudo -u odoo git clone https://github.com/odoo/enterprise -b ${args[version]}.0 /share/odoo/${args[version]}.0/enterprise
}

# :command.function
oda.sh_fs_odoo_update_command() {
	# src/fs_odoo_update_command.sh
	sudo -u odoo bash -c "cd /share/odoo/${args[version]}.0/odoo && git pull"
	sudo -u odoo bash -c "cd /share/odoo/${args[version]}.0/enterprise && git pull"
}

# :command.function
oda.sh_fs_project_init_command() {
	# src/fs_project_init_command.sh
	function configfile(){
	cat <<-_EOF_ | sudo -u odoo tee /share/projects/${args[projectname]}/${args[branch]}/conf/odoo.conf > /dev/null
	[options]
	addons_path = /opt/odoo/odoo/addons,/opt/odoo/enterprise,/opt/odoo/addons
	data_dir = /opt/odoo/data
	admin_passwd = adminadmin
	without_demo = all
	csv_internal_sep = ;
	db_host = db
	db_port = 5432
	db_maxconn = 24
	db_user = odoo${1}
	db_password = odooodoo
	db_name = ${args[projectname]}${args[branch]}
	db_template = template0
	db_sslmode = disable
	list_db = False
	proxy = True
	proxy_mode = True
	http_enable = True
	http_interface =
	http_port = 8069
	reportgz = False
	syslog = True
	log_level = debug
	# log_handler = werkzeug:CRITICAL,odoo.api:DEBUG
	# log_db_level = warning
	workers = 4
	max_cron_threads = 2
	limit_memory_hard = 2684354560
	limit_memory_soft = 2147483648
	limit_request = 8192
	limit_time_cpu = 1200
	limit_time_real = 2400
	_EOF_
	}

	sudo -u odoo mkdir -p /share/projects/${args[projectname]}/${args[branch]}/{data,conf}
	sudo -u odoo git clone ${args[projecturl]} -b ${args[branch]} /share/projects/${args[projectname]}/${args[branch]}/addons
	configfile ${args[version]}
}

# :command.function
oda.sh_fs_project_update_command() {
	# src/fs_project_update_command.sh
	sudo -u odoo bash -c "cd /share/projects/${args[projectname]}/${args[branch]}/addons && git pull"
}

# :command.function
oda.sh_remote_odoo_update_command() {
	# src/remote_odoo_update_command.sh
	ssh ${args[remote]} oda fs odoo update ${args[version]}
}

# :command.function
oda.sh_remote_project_init_command() {
	# src/remote_project_init_command.sh
	ssh ${args[remote]} oda fs project init ${args[version]} ${args[projectname]} ${args[branch]} ${args[projecturl]}

}

# :command.function
oda.sh_remote_project_update_command() {
	# src/remote_project_update_command.sh
	ssh ${args[remote]} oda fs project update ${args[projectname]} ${args[branch]}

}

# :command.function
oda.sh_remote_backup_command() {
	# src/remote_backup_command.sh
	ssh ${args[node]} oda node backup
}

# :command.function
oda.sh_remote_restore_command() {
	# src/remote_restore_command.sh
	REMOTE_FS=odoofs
	PROJECT=$(ssh ${args[node]} -- cat /etc/fstab | grep addons | awk '{print $1}' | awk -F':' '{print $2}' | sed 's,/addons$,,')
	DB=$(ssh ${args[node]} -- grep db_name /opt/odoo/conf/odoo.conf | sed 's/ //g' | awk -F'=' '{print $2}')
	ssh ${REMOTE_FS} -- sudo -u odoo rm -rf ${PROJECT}/data/*
	ssh ${REMOTE_FS} -- sudo -u odoo mkdir -p ${PROJECT}/data/filestore/${DB}
	ssh ${REMOTE_FS} -- sudo -u odoo tar -axf /share/${args[file]} -C ${PROJECT}/data/filestore/${DB} --strip-components=2 ./filestore

	# stop service
	ssh ${args[node]} -- sudo systemctl stop odoo.service

	# restore database via node
	ssh ${args[node]} -- "cd /opt/odoo && sudo -u odoo python3 -B /usr/local/bin/oda_db.py --remote -r -d ${args[file]} "

}

# :command.function
oda.sh_remote_mount_command() {
	# src/remote_mount_command.sh
	ssh ${args[node]} oda node mount ${args[version]} ${args[projectname]} ${args[branch]}
}

# :command.function
oda.sh_remote_start_command() {
	# src/remote_start_command.sh
	ssh ${args[node]} oda node start
}

# :command.function
oda.sh_remote_stop_command() {
	# src/remote_stop_command.sh
	ssh ${args[node]} oda node stop
}

# :command.function
oda.sh_remote_restart_command() {
	# src/remote_restart_command.sh
	ssh ${args[node]} oda node restart

}

# :command.parse_requirements
parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--version | -v)
				version_command
				exit
				;;

			--help | -h)
				long_usage=yes
				oda.sh_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.environment_variables_filter
	# :command.environment_variables_default
	export POD="${POD:-${PWD##*/}}"

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		config)
			action="config"
			shift
			oda.sh_config_parse_requirements "$@"
			shift $#
			;;

		start)
			action="start"
			shift
			oda.sh_start_parse_requirements "$@"
			shift $#
			;;

		stop)
			action="stop"
			shift
			oda.sh_stop_parse_requirements "$@"
			shift $#
			;;

		restart)
			action="restart"
			shift
			oda.sh_restart_parse_requirements "$@"
			shift $#
			;;

		logs)
			action="logs"
			shift
			oda.sh_logs_parse_requirements "$@"
			shift $#
			;;

		scaffold)
			action="scaffold"
			shift
			oda.sh_scaffold_parse_requirements "$@"
			shift $#
			;;

		init)
			action="init"
			shift
			oda.sh_init_parse_requirements "$@"
			shift $#
			;;

		install)
			action="install"
			shift
			oda.sh_install_parse_requirements "$@"
			shift $#
			;;

		upgrade)
			action="upgrade"
			shift
			oda.sh_upgrade_parse_requirements "$@"
			shift $#
			;;

		manifest)
			action="manifest"
			shift
			oda.sh_manifest_parse_requirements "$@"
			shift $#
			;;

		psql)
			action="psql"
			shift
			oda.sh_psql_parse_requirements "$@"
			shift $#
			;;

		query)
			action="query"
			shift
			oda.sh_query_parse_requirements "$@"
			shift $#
			;;

		backup)
			action="backup"
			shift
			oda.sh_backup_parse_requirements "$@"
			shift $#
			;;

		restore)
			action="restore"
			shift
			oda.sh_restore_parse_requirements "$@"
			shift $#
			;;

		admin)
			action="admin"
			shift
			oda.sh_admin_parse_requirements "$@"
			shift $#
			;;

		project)
			action="project"
			shift
			oda.sh_project_parse_requirements "$@"
			shift $#
			;;

		repo)
			action="repo"
			shift
			oda.sh_repo_parse_requirements "$@"
			shift $#
			;;

		node)
			action="node"
			shift
			oda.sh_node_parse_requirements "$@"
			shift $#
			;;

		fs)
			action="fs"
			shift
			oda.sh_fs_parse_requirements "$@"
			shift $#
			;;

		remote)
			action="remote"
			shift
			oda.sh_remote_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_config_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_config_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		vscode)
			action="vscode"
			shift
			oda.sh_config_vscode_parse_requirements "$@"
			shift $#
			;;

		pyright)
			action="pyright"
			shift
			oda.sh_config_pyright_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_config_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_config_vscode_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_config_vscode_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="config vscode"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_config_pyright_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_config_pyright_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="config pyright"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_start_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_start_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="start"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_stop_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_stop_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="stop"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_restart_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_restart_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="restart"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_logs_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_logs_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="logs"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_scaffold_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_scaffold_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="scaffold"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['module']+x} ]]; then

					args['module']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['module']+x} ]]; then
		printf "missing required argument: MODULE\nusage: oda.sh scaffold MODULE\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_init_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_init_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="init"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--name | -d)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name, -d NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['modules']+x} ]]; then

					args['modules']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['modules']:-} ]] || args['modules']="base,l10n_ca"
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_install_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_install_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="install"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--name | -d)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name, -d NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['modules']+x} ]]; then

					args['modules']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['modules']+x} ]]; then
		printf "missing required argument: MODULES\nusage: oda.sh install MODULES [OPTIONS]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_upgrade_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_upgrade_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="upgrade"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--name | -d)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name, -d NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['modules']+x} ]]; then

					args['modules']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['modules']+x} ]]; then
		printf "missing required argument: MODULES\nusage: oda.sh upgrade MODULES [OPTIONS]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_manifest_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_manifest_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		export)
			action="export"
			shift
			oda.sh_manifest_export_parse_requirements "$@"
			shift $#
			;;

		import)
			action="import"
			shift
			oda.sh_manifest_import_parse_requirements "$@"
			shift $#
			;;

		remote)
			action="remote"
			shift
			oda.sh_manifest_remote_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_manifest_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_manifest_export_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_manifest_export_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="manifest export"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_manifest_import_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_manifest_import_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="manifest import"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['file']+x} ]]; then

					args['file']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['file']:-} ]] || args['file']="manifest.json"

}

# :command.parse_requirements
oda.sh_manifest_remote_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_manifest_remote_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="manifest remote"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['file']+x} ]]; then

					args['file']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['file']+x} ]]; then
		printf "missing required argument: FILE\nusage: oda.sh manifest remote FILE\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_psql_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_psql_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="psql"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--host)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--host']="$2"
					shift
					shift
				else
					printf "%s\n" "--host requires an argument: --host HOST" >&2
					exit 1
				fi
				;;

			# :flag.case
			--port)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--port']="$2"
					shift
					shift
				else
					printf "%s\n" "--port requires an argument: --port PORT" >&2
					exit 1
				fi
				;;

			# :flag.case
			--user)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--user']="$2"
					shift
					shift
				else
					printf "%s\n" "--user requires an argument: --user USERNAME" >&2
					exit 1
				fi
				;;

			# :flag.case
			--pass)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--pass']="$2"
					shift
					shift
				else
					printf "%s\n" "--pass requires an argument: --pass PASS" >&2
					exit 1
				fi
				;;

			# :flag.case
			--name)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['--host']:-} ]] || args['--host']="$(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--port']:-} ]] || args['--port']="$(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--user']:-} ]] || args['--user']="$(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--pass']:-} ]] || args['--pass']="$(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_query_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_query_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="query"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--db_name)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--db_name']="$2"
					shift
					shift
				else
					printf "%s\n" "--db_name requires an argument: --db_name DATABASE" >&2
					exit 1
				fi
				;;

			# :flag.case
			-U)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['-U']="$2"
					shift
					shift
				else
					printf "%s\n" "-U requires an argument: -U USERNAME" >&2
					exit 1
				fi
				;;

			# :flag.case
			-P)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['-P']="$2"
					shift
					shift
				else
					printf "%s\n" "-P requires an argument: -P PASSWORD" >&2
					exit 1
				fi
				;;

			# :flag.case
			--filter)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--filter']="$2"
					shift
					shift
				else
					printf "%s\n" "--filter requires an argument: --filter FILTER" >&2
					exit 1
				fi
				;;

			# :flag.case
			--fields)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--fields']="$2"
					shift
					shift
				else
					printf "%s\n" "--fields requires an argument: --fields FIELDS" >&2
					exit 1
				fi
				;;

			# :flag.case
			--limit)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--limit']="$2"
					shift
					shift
				else
					printf "%s\n" "--limit requires an argument: --limit LIMIT" >&2
					exit 1
				fi
				;;

			# :flag.case
			--offset)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--offset']="$2"
					shift
					shift
				else
					printf "%s\n" "--offset requires an argument: --offset OFFSET" >&2
					exit 1
				fi
				;;

			# :flag.case
			--count)

				# :flag.case_no_arg
				args['--count']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['model']+x} ]]; then

					args['model']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['model']+x} ]]; then
		printf "missing required argument: MODEL\nusage: oda.sh query MODEL [OPTIONS]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['--db_name']:-} ]] || args['--db_name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['-U']:-} ]] || args['-U']="admin"
	[[ -n ${args['-P']:-} ]] || args['-P']="admin"
	[[ -n ${args['--filter']:-} ]] || args['--filter']=""

}

# :command.parse_requirements
oda.sh_backup_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_backup_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="backup"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_restore_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_restore_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="restore"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_repeatable

				if [[ -z ${args['file']+x} ]]; then
					args['file']="\"$1\""
					shift
				else
					args['file']="${args[file]} \"$1\""
					shift
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['file']+x} ]]; then
		printf "missing required argument: FILE\nusage: oda.sh restore FILE...\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_admin_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_admin_usage
				exit
				;;

			# :flag.case
			--host)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--host']="$2"
					shift
					shift
				else
					printf "%s\n" "--host requires an argument: --host HOST" >&2
					exit 1
				fi
				;;

			# :flag.case
			--port)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--port']="$2"
					shift
					shift
				else
					printf "%s\n" "--port requires an argument: --port PORT" >&2
					exit 1
				fi
				;;

			# :flag.case
			--db_user)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--db_user']="$2"
					shift
					shift
				else
					printf "%s\n" "--db_user requires an argument: --db_user DB_USERNAME" >&2
					exit 1
				fi
				;;

			# :flag.case
			--db_pass)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--db_pass']="$2"
					shift
					shift
				else
					printf "%s\n" "--db_pass requires an argument: --db_pass DB_PASS" >&2
					exit 1
				fi
				;;

			# :flag.case
			--db_name)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--db_name']="$2"
					shift
					shift
				else
					printf "%s\n" "--db_name requires an argument: --db_name DB_NAME" >&2
					exit 1
				fi
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		user)
			action="user"
			shift
			oda.sh_admin_user_parse_requirements "$@"
			shift $#
			;;

		password)
			action="password"
			shift
			oda.sh_admin_password_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_admin_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['--host']:-} ]] || args['--host']="$(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--port']:-} ]] || args['--port']="$(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--db_user']:-} ]] || args['--db_user']="$(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--db_pass']:-} ]] || args['--db_pass']="$(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--db_name']:-} ]] || args['--db_name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_admin_user_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_admin_user_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="admin user"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['admin_name']+x} ]]; then

					args['admin_name']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_admin_password_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_admin_password_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="admin password"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['admin_password']+x} ]]; then

					args['admin_password']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['admin_password']+x} ]]; then
		printf "missing required argument: ADMIN_PASSWORD\nusage: oda.sh admin password ADMIN_PASSWORD\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_project_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_project_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.environment_variables_filter
	# :command.environment_variables_default
	export ODOOBASE="${ODOOBASE:-${HOME}/workspace/repos/odoo}"

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		init)
			action="init"
			shift
			oda.sh_project_init_parse_requirements "$@"
			shift $#
			;;

		branch)
			action="branch"
			shift
			oda.sh_project_branch_parse_requirements "$@"
			shift $#
			;;

		reset)
			action="reset"
			shift
			oda.sh_project_reset_parse_requirements "$@"
			shift $#
			;;

		destroy)
			action="destroy"
			shift
			oda.sh_project_destroy_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_project_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_project_init_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_project_init_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.environment_variables_filter
	# :command.environment_variables_default
	export IPV4="${IPV4:-$(ip -4 -br a show | grep -v ^lo | grep UP | awk '{print $3}' | awk -F'/' '{print $1}')}"

	# :command.command_filter
	action="project init"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['oport']+x} ]]; then

					args['oport']=$1
					shift
				elif [[ -z ${args['pgport']+x} ]]; then

					args['pgport']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh project init VERSION PROJECTNAME [OPORT] [PGPORT]\n" >&2
		exit 1
	fi
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh project init VERSION PROJECTNAME [OPORT] [PGPORT]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['oport']:-} ]] || args['oport']="8069"
	[[ -n ${args['pgport']:-} ]] || args['pgport']="5432"

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_project_branch_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_project_branch_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.environment_variables_filter
	# :command.environment_variables_default
	export IPV4="${IPV4:-$(ip -4 -br a show | grep -v ^lo | grep UP | awk '{print $3}' | awk -F'/' '{print $1}')}"

	# :command.command_filter
	action="project branch"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				elif [[ -z ${args['url']+x} ]]; then

					args['url']=$1
					shift
				elif [[ -z ${args['oport']+x} ]]; then

					args['oport']=$1
					shift
				elif [[ -z ${args['pgport']+x} ]]; then

					args['pgport']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh project branch VERSION PROJECTNAME BRANCH URL [OPORT] [PGPORT]\n" >&2
		exit 1
	fi
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh project branch VERSION PROJECTNAME BRANCH URL [OPORT] [PGPORT]\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh project branch VERSION PROJECTNAME BRANCH URL [OPORT] [PGPORT]\n" >&2
		exit 1
	fi
	if [[ -z ${args['url']+x} ]]; then
		printf "missing required argument: URL\nusage: oda.sh project branch VERSION PROJECTNAME BRANCH URL [OPORT] [PGPORT]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['oport']:-} ]] || args['oport']="8069"
	[[ -n ${args['pgport']:-} ]] || args['pgport']="5432"

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_project_reset_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_project_reset_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="project reset"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--host)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--host']="$2"
					shift
					shift
				else
					printf "%s\n" "--host requires an argument: --host HOST" >&2
					exit 1
				fi
				;;

			# :flag.case
			--port)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--port']="$2"
					shift
					shift
				else
					printf "%s\n" "--port requires an argument: --port PORT" >&2
					exit 1
				fi
				;;

			# :flag.case
			--user)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--user']="$2"
					shift
					shift
				else
					printf "%s\n" "--user requires an argument: --user USERNAME" >&2
					exit 1
				fi
				;;

			# :flag.case
			--pass)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--pass']="$2"
					shift
					shift
				else
					printf "%s\n" "--pass requires an argument: --pass PASS" >&2
					exit 1
				fi
				;;

			# :flag.case
			--name)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['--host']:-} ]] || args['--host']="$(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--port']:-} ]] || args['--port']="$(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--user']:-} ]] || args['--user']="$(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--pass']:-} ]] || args['--pass']="$(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_project_destroy_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_project_destroy_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="project destroy"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--host)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--host']="$2"
					shift
					shift
				else
					printf "%s\n" "--host requires an argument: --host HOST" >&2
					exit 1
				fi
				;;

			# :flag.case
			--port)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--port']="$2"
					shift
					shift
				else
					printf "%s\n" "--port requires an argument: --port PORT" >&2
					exit 1
				fi
				;;

			# :flag.case
			--user)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--user']="$2"
					shift
					shift
				else
					printf "%s\n" "--user requires an argument: --user USERNAME" >&2
					exit 1
				fi
				;;

			# :flag.case
			--pass)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--pass']="$2"
					shift
					shift
				else
					printf "%s\n" "--pass requires an argument: --pass PASS" >&2
					exit 1
				fi
				;;

			# :flag.case
			--name)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['--host']:-} ]] || args['--host']="$(grep db_host conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--port']:-} ]] || args['--port']="$(grep db_port conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--user']:-} ]] || args['--user']="$(grep db_user conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--pass']:-} ]] || args['--pass']="$(grep db_pass conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_repo_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.environment_variables_filter
	# :command.environment_variables_default
	export ODOOBASE="${ODOOBASE:-${HOME}/workspace/repos/odoo}"

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		base)
			action="base"
			shift
			oda.sh_repo_base_parse_requirements "$@"
			shift $#
			;;

		version)
			action="version"
			shift
			oda.sh_repo_version_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_repo_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_repo_base_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_base_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		clone)
			action="clone"
			shift
			oda.sh_repo_base_clone_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			oda.sh_repo_base_update_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_repo_base_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_repo_base_clone_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_base_clone_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="repo base clone"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_repo_base_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_base_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="repo base update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_repo_version_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_version_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		clone)
			action="clone"
			shift
			oda.sh_repo_version_clone_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			oda.sh_repo_version_update_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_repo_version_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_repo_version_clone_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_version_clone_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="repo version clone"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh repo version clone VERSION\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_repo_version_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_repo_version_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="repo version update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh repo version update VERSION\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_node_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		start)
			action="start"
			shift
			oda.sh_node_start_parse_requirements "$@"
			shift $#
			;;

		stop)
			action="stop"
			shift
			oda.sh_node_stop_parse_requirements "$@"
			shift $#
			;;

		restart)
			action="restart"
			shift
			oda.sh_node_restart_parse_requirements "$@"
			shift $#
			;;

		logs)
			action="logs"
			shift
			oda.sh_node_logs_parse_requirements "$@"
			shift $#
			;;

		mount)
			action="mount"
			shift
			oda.sh_node_mount_parse_requirements "$@"
			shift $#
			;;

		backup)
			action="backup"
			shift
			oda.sh_node_backup_parse_requirements "$@"
			shift $#
			;;

		restore)
			action="restore"
			shift
			oda.sh_node_restore_parse_requirements "$@"
			shift $#
			;;

		requirements)
			action="requirements"
			shift
			oda.sh_node_requirements_parse_requirements "$@"
			shift $#
			;;

		systemd)
			action="systemd"
			shift
			oda.sh_node_systemd_parse_requirements "$@"
			shift $#
			;;

		logger)
			action="logger"
			shift
			oda.sh_node_logger_parse_requirements "$@"
			shift $#
			;;

		project)
			action="project"
			shift
			oda.sh_node_project_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_node_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_start_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_start_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node start"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_stop_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_stop_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node stop"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_restart_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_restart_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node restart"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_logs_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_logs_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node logs"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_mount_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_mount_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node mount"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh node mount VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh node mount VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh node mount VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_node_backup_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_backup_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node backup"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_restore_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_restore_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node restore"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--remote)

				# :flag.case_no_arg
				args['--remote']=1
				shift
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_repeatable

				if [[ -z ${args['file']+x} ]]; then
					args['file']="\"$1\""
					shift
				else
					args['file']="${args[file]} \"$1\""
					shift
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['file']+x} ]]; then
		printf "missing required argument: FILE\nusage: oda.sh node restore FILE... [OPTIONS]\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_node_requirements_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_requirements_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node requirements"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['fsip']+x} ]]; then

					args['fsip']=$1
					shift
				elif [[ -z ${args['dbip']+x} ]]; then

					args['dbip']=$1
					shift
				elif [[ -z ${args['loggerip']+x} ]]; then

					args['loggerip']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['fsip']+x} ]]; then
		printf "missing required argument: FSIP\nusage: oda.sh node requirements FSIP DBIP LOGGERIP\n" >&2
		exit 1
	fi
	if [[ -z ${args['dbip']+x} ]]; then
		printf "missing required argument: DBIP\nusage: oda.sh node requirements FSIP DBIP LOGGERIP\n" >&2
		exit 1
	fi
	if [[ -z ${args['loggerip']+x} ]]; then
		printf "missing required argument: LOGGERIP\nusage: oda.sh node requirements FSIP DBIP LOGGERIP\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_node_systemd_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_systemd_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node systemd"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_logger_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_logger_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node logger"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_project_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_project_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		reset)
			action="reset"
			shift
			oda.sh_node_project_reset_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_node_project_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_node_project_reset_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_node_project_reset_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="node project reset"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in
			# :flag.case
			--host)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--host']="$2"
					shift
					shift
				else
					printf "%s\n" "--host requires an argument: --host HOST" >&2
					exit 1
				fi
				;;

			# :flag.case
			--port)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--port']="$2"
					shift
					shift
				else
					printf "%s\n" "--port requires an argument: --port PORT" >&2
					exit 1
				fi
				;;

			# :flag.case
			--user)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--user']="$2"
					shift
					shift
				else
					printf "%s\n" "--user requires an argument: --user USERNAME" >&2
					exit 1
				fi
				;;

			# :flag.case
			--pass)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--pass']="$2"
					shift
					shift
				else
					printf "%s\n" "--pass requires an argument: --pass PASS" >&2
					exit 1
				fi
				;;

			# :flag.case
			--name)

				# :flag.case_arg
				if [[ -n ${2+x} ]]; then

					args['--name']="$2"
					shift
					shift
				else
					printf "%s\n" "--name requires an argument: --name NAME" >&2
					exit 1
				fi
				;;

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

	# :command.default_assignments
	[[ -n ${args['--host']:-} ]] || args['--host']="$(grep db_host /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--port']:-} ]] || args['--port']="$(grep db_port /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--user']:-} ]] || args['--user']="$(grep db_user /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--pass']:-} ]] || args['--pass']="$(grep db_pass /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"
	[[ -n ${args['--name']:-} ]] || args['--name']="$(grep db_name /opt/odoo/conf/odoo.conf | awk -F'=' '{print $2}' | tr -d '[:space:]')"

}

# :command.parse_requirements
oda.sh_fs_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		odoo)
			action="odoo"
			shift
			oda.sh_fs_odoo_parse_requirements "$@"
			shift $#
			;;

		project)
			action="project"
			shift
			oda.sh_fs_project_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_fs_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_fs_odoo_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_odoo_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		init)
			action="init"
			shift
			oda.sh_fs_odoo_init_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			oda.sh_fs_odoo_update_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_fs_odoo_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_fs_odoo_init_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_odoo_init_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="fs odoo init"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh fs odoo init VERSION\n" >&2
		exit 1
	fi

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_fs_odoo_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_odoo_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="fs odoo update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh fs odoo update VERSION\n" >&2
		exit 1
	fi

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_fs_project_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_project_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		init)
			action="init"
			shift
			oda.sh_fs_project_init_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			oda.sh_fs_project_update_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_fs_project_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_fs_project_init_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_project_init_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="fs project init"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				elif [[ -z ${args['projecturl']+x} ]]; then

					args['projecturl']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh fs project init VERSION PROJECTNAME BRANCH PROJECTURL\n" >&2
		exit 1
	fi
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh fs project init VERSION PROJECTNAME BRANCH PROJECTURL\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh fs project init VERSION PROJECTNAME BRANCH PROJECTURL\n" >&2
		exit 1
	fi
	if [[ -z ${args['projecturl']+x} ]]; then
		printf "missing required argument: PROJECTURL\nusage: oda.sh fs project init VERSION PROJECTNAME BRANCH PROJECTURL\n" >&2
		exit 1
	fi

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_fs_project_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_fs_project_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="fs project update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh fs project update PROJECTNAME BRANCH\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh fs project update PROJECTNAME BRANCH\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		odoo)
			action="odoo"
			shift
			oda.sh_remote_odoo_parse_requirements "$@"
			shift $#
			;;

		project)
			action="project"
			shift
			oda.sh_remote_project_parse_requirements "$@"
			shift $#
			;;

		backup)
			action="backup"
			shift
			oda.sh_remote_backup_parse_requirements "$@"
			shift $#
			;;

		restore)
			action="restore"
			shift
			oda.sh_remote_restore_parse_requirements "$@"
			shift $#
			;;

		mount)
			action="mount"
			shift
			oda.sh_remote_mount_parse_requirements "$@"
			shift $#
			;;

		start)
			action="start"
			shift
			oda.sh_remote_start_parse_requirements "$@"
			shift $#
			;;

		stop)
			action="stop"
			shift
			oda.sh_remote_stop_parse_requirements "$@"
			shift $#
			;;

		restart)
			action="restart"
			shift
			oda.sh_remote_restart_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_remote_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_remote_odoo_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_odoo_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		update)
			action="update"
			shift
			oda.sh_remote_odoo_update_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_remote_odoo_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_remote_odoo_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_odoo_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote odoo update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['remote']+x} ]]; then

					args['remote']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh remote odoo update VERSION [REMOTE]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['remote']:-} ]] || args['remote']="odoofs"

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_project_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_project_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action=${1:-}

	case $action in
		-*) ;;

		init)
			action="init"
			shift
			oda.sh_remote_project_init_parse_requirements "$@"
			shift $#
			;;

		update)
			action="update"
			shift
			oda.sh_remote_project_update_parse_requirements "$@"
			shift $#
			;;

		# :command.command_fallback
		"")
			oda.sh_remote_project_usage >&2
			exit 1
			;;

		*)
			printf "invalid command: %s\n" "$action" >&2
			exit 1
			;;

	esac

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				printf "invalid argument: %s\n" "$key" >&2
				exit 1

				;;

		esac
	done

}

# :command.parse_requirements
oda.sh_remote_project_init_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_project_init_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote project init"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				elif [[ -z ${args['projecturl']+x} ]]; then

					args['projecturl']=$1
					shift
				elif [[ -z ${args['remote']+x} ]]; then

					args['remote']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh remote project init VERSION PROJECTNAME BRANCH PROJECTURL [REMOTE]\n" >&2
		exit 1
	fi
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh remote project init VERSION PROJECTNAME BRANCH PROJECTURL [REMOTE]\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh remote project init VERSION PROJECTNAME BRANCH PROJECTURL [REMOTE]\n" >&2
		exit 1
	fi
	if [[ -z ${args['projecturl']+x} ]]; then
		printf "missing required argument: PROJECTURL\nusage: oda.sh remote project init VERSION PROJECTNAME BRANCH PROJECTURL [REMOTE]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['remote']:-} ]] || args['remote']="odoofs"

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_project_update_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_project_update_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote project update"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				elif [[ -z ${args['remote']+x} ]]; then

					args['remote']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh remote project update PROJECTNAME BRANCH [REMOTE]\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh remote project update PROJECTNAME BRANCH [REMOTE]\n" >&2
		exit 1
	fi

	# :command.default_assignments
	[[ -n ${args['remote']:-} ]] || args['remote']="odoofs"

}

# :command.parse_requirements
oda.sh_remote_backup_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_backup_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote backup"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['node']+x} ]]; then

					args['node']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['node']+x} ]]; then
		printf "missing required argument: NODE\nusage: oda.sh remote backup NODE\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_restore_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_restore_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote restore"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_repeatable

				if [[ -z ${args['node']+x} ]]; then
					args['node']=$1
					shift

				elif [[ -z ${args['file']+x} ]]; then
					args['file']="\"$1\""
					shift
				else
					args['file']="${args[file]} \"$1\""
					shift
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['node']+x} ]]; then
		printf "missing required argument: NODE\nusage: oda.sh remote restore NODE FILE...\n" >&2
		exit 1
	fi
	if [[ -z ${args['file']+x} ]]; then
		printf "missing required argument: FILE\nusage: oda.sh remote restore NODE FILE...\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_mount_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_mount_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote mount"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['node']+x} ]]; then

					args['node']=$1
					shift
				elif [[ -z ${args['version']+x} ]]; then

					args['version']=$1
					shift
				elif [[ -z ${args['projectname']+x} ]]; then

					args['projectname']=$1
					shift
				elif [[ -z ${args['branch']+x} ]]; then

					args['branch']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['node']+x} ]]; then
		printf "missing required argument: NODE\nusage: oda.sh remote mount NODE VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi
	if [[ -z ${args['version']+x} ]]; then
		printf "missing required argument: VERSION\nusage: oda.sh remote mount NODE VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi
	if [[ -z ${args['projectname']+x} ]]; then
		printf "missing required argument: PROJECTNAME\nusage: oda.sh remote mount NODE VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi
	if [[ -z ${args['branch']+x} ]]; then
		printf "missing required argument: BRANCH\nusage: oda.sh remote mount NODE VERSION PROJECTNAME BRANCH\n" >&2
		exit 1
	fi

	# :command.whitelist_filter
	if [[ -n ${args['version']} ]] && [[ ! ${args['version']} =~ ^(15|16|17)$ ]]; then
		printf "%s\n" "version must be one of: 15, 16, 17" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_start_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_start_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote start"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['node']+x} ]]; then

					args['node']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['node']+x} ]]; then
		printf "missing required argument: NODE\nusage: oda.sh remote start NODE\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_stop_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_stop_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote stop"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['node']+x} ]]; then

					args['node']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['node']+x} ]]; then
		printf "missing required argument: NODE\nusage: oda.sh remote stop NODE\n" >&2
		exit 1
	fi

}

# :command.parse_requirements
oda.sh_remote_restart_parse_requirements() {
	# :command.fixed_flags_filter
	while [[ $# -gt 0 ]]; do
		case "${1:-}" in
			--help | -h)
				long_usage=yes
				oda.sh_remote_restart_usage
				exit
				;;

			*)
				break
				;;

		esac
	done

	# :command.command_filter
	action="remote restart"

	# :command.parse_requirements_while
	while [[ $# -gt 0 ]]; do
		key="$1"
		case "$key" in

			-?*)
				printf "invalid option: %s\n" "$key" >&2
				exit 1
				;;

			*)
				# :command.parse_requirements_case
				# :command.parse_requirements_case_simple
				if [[ -z ${args['node']+x} ]]; then

					args['node']=$1
					shift
				else
					printf "invalid argument: %s\n" "$key" >&2
					exit 1
				fi

				;;

		esac
	done

	# :command.required_args_filter
	if [[ -z ${args['node']+x} ]]; then
		printf "missing required argument: NODE\nusage: oda.sh remote restart NODE\n" >&2
		exit 1
	fi

}

# :command.initialize
initialize() {
	version="0.1.0"
	long_usage=''
	set -e

	# :command.environment_variables_default
	export POD="${POD:-${PWD##*/}}"

}

# :command.run
run() {
	declare -A args=()
	declare -A deps=()
	declare -a other_args=()
	declare -a input=()
	normalize_input "$@"
	parse_requirements "${input[@]}"

	case "$action" in
		"config") oda.sh_config_command ;;
		"config vscode") oda.sh_config_vscode_command ;;
		"config pyright") oda.sh_config_pyright_command ;;
		"start") oda.sh_start_command ;;
		"stop") oda.sh_stop_command ;;
		"restart") oda.sh_restart_command ;;
		"logs") oda.sh_logs_command ;;
		"scaffold") oda.sh_scaffold_command ;;
		"init") oda.sh_init_command ;;
		"install") oda.sh_install_command ;;
		"upgrade") oda.sh_upgrade_command ;;
		"manifest") oda.sh_manifest_command ;;
		"manifest export") oda.sh_manifest_export_command ;;
		"manifest import") oda.sh_manifest_import_command ;;
		"manifest remote") oda.sh_manifest_remote_command ;;
		"psql") oda.sh_psql_command ;;
		"query") oda.sh_query_command ;;
		"backup") oda.sh_backup_command ;;
		"restore") oda.sh_restore_command ;;
		"admin") oda.sh_admin_command ;;
		"admin user") oda.sh_admin_user_command ;;
		"admin password") oda.sh_admin_password_command ;;
		"project") oda.sh_project_command ;;
		"project init") oda.sh_project_init_command ;;
		"project branch") oda.sh_project_branch_command ;;
		"project reset") oda.sh_project_reset_command ;;
		"project destroy") oda.sh_project_destroy_command ;;
		"repo") oda.sh_repo_command ;;
		"repo base") oda.sh_repo_base_command ;;
		"repo base clone") oda.sh_repo_base_clone_command ;;
		"repo base update") oda.sh_repo_base_update_command ;;
		"repo version") oda.sh_repo_version_command ;;
		"repo version clone") oda.sh_repo_version_clone_command ;;
		"repo version update") oda.sh_repo_version_update_command ;;
		"node") oda.sh_node_command ;;
		"node start") oda.sh_node_start_command ;;
		"node stop") oda.sh_node_stop_command ;;
		"node restart") oda.sh_node_restart_command ;;
		"node logs") oda.sh_node_logs_command ;;
		"node mount") oda.sh_node_mount_command ;;
		"node backup") oda.sh_node_backup_command ;;
		"node restore") oda.sh_node_restore_command ;;
		"node requirements") oda.sh_node_requirements_command ;;
		"node systemd") oda.sh_node_systemd_command ;;
		"node logger") oda.sh_node_logger_command ;;
		"node project") oda.sh_node_project_command ;;
		"node project reset") oda.sh_node_project_reset_command ;;
		"fs") oda.sh_fs_command ;;
		"fs odoo") oda.sh_fs_odoo_command ;;
		"fs odoo init") oda.sh_fs_odoo_init_command ;;
		"fs odoo update") oda.sh_fs_odoo_update_command ;;
		"fs project") oda.sh_fs_project_command ;;
		"fs project init") oda.sh_fs_project_init_command ;;
		"fs project update") oda.sh_fs_project_update_command ;;
		"remote") oda.sh_remote_command ;;
		"remote odoo") oda.sh_remote_odoo_command ;;
		"remote odoo update") oda.sh_remote_odoo_update_command ;;
		"remote project") oda.sh_remote_project_command ;;
		"remote project init") oda.sh_remote_project_init_command ;;
		"remote project update") oda.sh_remote_project_update_command ;;
		"remote backup") oda.sh_remote_backup_command ;;
		"remote restore") oda.sh_remote_restore_command ;;
		"remote mount") oda.sh_remote_mount_command ;;
		"remote start") oda.sh_remote_start_command ;;
		"remote stop") oda.sh_remote_stop_command ;;
		"remote restart") oda.sh_remote_restart_command ;;
	esac
}

initialize
run "$@"
